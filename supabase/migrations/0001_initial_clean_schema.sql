
-- Passo 1: Remover tabelas não utilizadas e legadas.
-- É seguro executar isso, pois as tabelas já foram validadas como não utilizadas no código.
DROP TABLE IF EXISTS public.assinaturas CASCADE;
DROP TABLE IF EXISTS public.clientes CASCADE;
DROP TABLE IF EXISTS public.pagamentos CASCADE;
DROP TABLE IF EXISTS public.planos_recorrencia CASCADE;
DROP TABLE IF EXISTS public.status_options CASCADE;
DROP TABLE IF EXISTS public.user_payments CASCADE;
DROP TABLE IF EXISTS public.user_status CASCADE;
DROP TABLE IF EXISTS public.usuarios CASCADE;

-- Passo 2: Garantir que as tabelas principais existam (não fará nada se já existirem).
CREATE TABLE IF NOT EXISTS public.clients (
    id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
    user_id uuid NULL,
    name text NOT NULL,
    phone text NOT NULL,
    monthly_payment numeric(10, 2) NOT NULL,
    status boolean NULL DEFAULT true,
    last_payment_date timestamp with time zone NULL,
    payment_due_day integer NULL,
    start_date date NOT NULL DEFAULT now(),
    payment_frequency public.payment_frequency_type NOT NULL DEFAULT 'monthly'::payment_frequency_type,
    next_payment_date timestamp with time zone NULL,
    device_key character varying(64) NULL,
    mac_address character varying(17) NULL,
    app character varying(36) NULL,
    created_at timestamp with time zone NULL DEFAULT now(),
    updated_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT clients_pkey PRIMARY KEY (id),
    CONSTRAINT clients_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE,
    CONSTRAINT clients_payment_due_day_check CHECK (((payment_due_day >= 1) AND (payment_due_day <= 31)))
);

CREATE TABLE IF NOT EXISTS public.notifications (
    id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
    user_id uuid NULL,
    client_id uuid NULL,
    type text NOT NULL,
    message text NOT NULL,
    status text NOT NULL,
    sent_at timestamp with time zone NULL DEFAULT now(),
    created_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT notifications_pkey PRIMARY KEY (id),
    CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE,
    CONSTRAINT notifications_client_id_fkey FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.password_reset_tokens (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    email text NOT NULL,
    token text NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT password_reset_tokens_pkey PRIMARY KEY (id),
    CONSTRAINT password_reset_tokens_token_key UNIQUE (token)
);

CREATE TABLE IF NOT EXISTS public.payments (
    id uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
    user_id uuid NULL,
    client_id uuid NULL,
    amount numeric(10, 2) NOT NULL,
    reference_month character varying(7) NULL,
    payment_date timestamp with time zone NULL DEFAULT now(),
    created_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT payments_pkey PRIMARY KEY (id),
    CONSTRAINT payments_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE CASCADE,
    CONSTRAINT payments_client_id_fkey FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL,
    name text NOT NULL,
    is_admin boolean NOT NULL DEFAULT false,
    last_payment_at timestamp with time zone NULL,
    next_payment_due_at timestamp with time zone NULL,
    created_at timestamp with time zone NULL DEFAULT now(),
    updated_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users (id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.pix_transactions (
    id serial NOT NULL,
    user_id uuid NOT NULL,
    transaction_id character varying(255) NOT NULL,
    amount numeric(10, 2) NOT NULL,
    status character varying(50) NOT NULL DEFAULT 'pending'::character varying,
    created_at timestamp with time zone NULL DEFAULT now(),
    updated_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT pix_transactions_pkey PRIMARY KEY (id),
    CONSTRAINT pix_transactions_transaction_id_key UNIQUE (transaction_id),
    CONSTRAINT pix_transactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id)
);

CREATE TABLE IF NOT EXISTS public.referral_credits (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    referrer_user_id uuid NOT NULL,
    referred_user_id uuid NOT NULL,
    referral_level integer NOT NULL,
    credit_amount numeric(10, 2) NOT NULL,
    status text NULL DEFAULT 'pending'::text,
    credited_at timestamp with time zone NULL,
    created_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT referral_credits_pkey PRIMARY KEY (id),
    CONSTRAINT referral_credits_referrer_user_id_fkey FOREIGN KEY (referrer_user_id) REFERENCES auth.users (id) ON DELETE CASCADE,
    CONSTRAINT referral_credits_referred_user_id_fkey FOREIGN KEY (referred_user_id) REFERENCES auth.users (id) ON DELETE CASCADE
);

-- Passo 3: Adicionar os índices que estão faltando para otimização.
CREATE INDEX IF NOT EXISTS idx_clients_user_id ON public.clients USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON public.notifications USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_client_id ON public.notifications USING btree (client_id);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_email ON public.password_reset_tokens USING btree (email);
CREATE INDEX IF NOT EXISTS idx_payments_client_id ON public.payments USING btree (client_id);

-- Passo 4: Garantir que os gatilhos (triggers) estejam corretamente configurados.
DROP TRIGGER IF EXISTS update_clients_updated_at ON public.clients;
CREATE TRIGGER update_clients_updated_at BEFORE UPDATE ON public.clients FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_last_payment_date ON public.payments;
CREATE TRIGGER update_last_payment_date AFTER INSERT ON public.payments FOR EACH ROW EXECUTE FUNCTION update_client_last_payment();

DROP TRIGGER IF EXISTS update_payments_updated_at ON public.payments;
CREATE TRIGGER update_payments_updated_at BEFORE UPDATE ON public.payments FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_profiles_updated_at();
